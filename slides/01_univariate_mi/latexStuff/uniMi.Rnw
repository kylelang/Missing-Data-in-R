%%% Title:    Missing Data Stats Camp Course: Univariate MI
%%% Author:   Kyle M. Lang
%%% Created:  2017-SEP-12
%%% Modified: 2018-OCT-18

\documentclass{beamer}
\usetheme[%
  pageofpages          = of,
  bullet               = circle,
  titleline            = true,
  alternativetitlepage = true,
  titlepagelogo        = Logo3,
  watermark            = watermarkTiU,
  watermarkheight      = 100px,
  watermarkheightmult  = 4%
]{UVT}

\usepackage{graphicx}
\usepackage{booktabs}
\usepackage[natbibapa]{apacite}
\usepackage[libertine]{newtxmath}
\usepackage{fancybox}

\newcommand{\kfold}[0]{\emph{K}-fold cross-validation}

%% Ensure styles of `blocks' (used in Definitions, Theorems etc.) follows the
%% UVT-style theme:
\setbeamercolor{block title}{fg = darkblue, bg = white}
\setbeamercolor{block body}{use = block title, bg = block title.bg}

%% Ensure TableOfContents is in UVT-style theme:
\setbeamercolor{section in toc}{fg = darkblue}

\title{Univariate Multiple Imputation}
\subtitle{Stats Camp 2018: Missing Data Analysis}
\author{Kyle M. Lang}
\institute{Department of Methodology \& Statistics\\Tilburg University}
\date{19--21 October 2018}

\begin{document}

%------------------------------------------------------------------------------%

<<setup, include=FALSE>>=
set.seed(235711)

library(knitr)
library(ggplot2)
library(MASS)
library(mvtnorm)
library(glmnet)
library(xtable)
library(pscl)
library(LaplacesDemon)
library(MLmetrics)
library(mitools)

source("../../../code/supportFunctions.R")
dataDir <- "../../../data/"
figDir  <- "figures/"

opts_chunk$set(size = 'footnotesize', fig.align = 'center')
knit_theme$set('edit-kwrite')

lightBlue <- rgb(0,   137, 191, max = 255)
midBlue   <- rgb(0,   131, 183, max = 255)
darkBlue  <- rgb(0,   128, 179, max = 255)
deepGold  <- rgb(184, 138, 45,  max = 255)
lightGold <- rgb(195, 146, 48,  max = 255)
@

%------------------------------------------------------------------------------%

\begin{frame}[t,plain]

  \titlepage

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Outline}
  
  \begin{itemize}
  \item Build up the basis for MI from linear regression.
  \item Demonstrate each step with examples in R.
  \item Show how to manually implement a simple MI in R.
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Brief Regression Refresher}
  
  Ordinary least squares (OLS) regression estimates the following model:
  \begin{align*}
    Y = \mathbf{X}\beta + \varepsilon
  \end{align*}
  By minimizing the residual sum of squared errors, we get the following 
  estimated regression coefficients:
  \begin{align*}
     \hat{\beta} = \left(\mathbf{X}^T \mathbf{X} \right)^{-1} \mathbf{X}^T Y
  \end{align*}
  We can predict the values of unobserved outcome data by applying the fitted 
  $\beta$s to new predictor data:
  \begin{align*}
    \hat{Y} = \mathbf{X}_{new}\hat{\beta}
  \end{align*}
  These predicted values are the basis for nearly all imputation methods.
  
\end{frame}

\watermarkoff %----------------------------------------------------------------%

\begin{frame}[fragile]{OLS Example}
    
<<size = "scriptsize">>= 
## Create some data:
X    <- cbind(1, rnorm(100))
beta <- matrix(c(0.25, 0.5))
y    <- X %*% beta + rnorm(100, 0.0, 0.1)

## R's built-in solution:
rFit <- lm(y ~ X - 1)
coef(rFit) # R's fitted coefficients

## Least squares by hand:
betaHat <- solve(t(X) %*% X) %*% t(X) %*% y
t(betaHat) # Our hand-fitted coefficients
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{OLS Example}

  \begin{columns}
    \begin{column}{0.5\textwidth}
      
<<>>=
## What about prediction?
X2   <- cbind(1, rnorm(100))
yHat <- X2 %*% betaHat
@

\end{column}
\begin{column}{0.5\textwidth}

<<echo = FALSE>>=
yDens    <- density(y)
yHatDens <- density(yHat)
yLim     <- range(c(yDens$y, yHatDens$y))
xLim     <- range(c(yDens$x, yHatDens$x))

plot(yDens,
     main = "Densities of Observed and Predicted Y",
     xlab = "Y Value",
     ylim = yLim,
     xlim = xLim)

lines(yDens)
lines(yHatDens, col = "red")

legend(x      = "topright",
       legend = c("Observed", "Predicted"),
       col    = c("black", "red"),
       lwd    = 2)
@ 

\end{column}
\end{columns}

\end{frame}

\watermarkon %-----------------------------------------------------------------%

\begin{frame}{Prediction}
  
  Train a model to predict BMI from diet-related and exercise-related features.
  \vb
  \begin{itemize}
  \item Plug-in new feature values corresponding to an experimental diet
    program to see the expected BMI for a hypothetical patient treated with the
    new program.  
  \end{itemize}
  \vb 
  Predict future gasoline prices based on geo-political events in
  oil-producing countries.  
  \vb
  \begin{itemize}
    \item If conflict escalates in the Middle East, adjust the appropriate
      features and project likely changes in gasoline prices.
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Prediction Example}
  
  To fix ideas, let's consider the \emph{diabetes} data and the following model:
  \begin{align*}
    Y_{LDL} = \beta_0 + \beta_1 X_{BP} + \beta_2 X_{gluc} + \beta_3 X_{BMI} + 
    \varepsilon
  \end{align*}
  
<<echo = FALSE>>=
diabetes <- readRDS(paste0(dataDir, "diabetes.rds"))

trainDat <- diabetes[1 : 400, ]
testDat  <- diabetes[401 : 442, ]

out1 <- lm(ldl ~ bp + glu + bmi, data = trainDat)

b0 <- round(coef(out1)[1], 3)
b1 <- round(coef(out1)[2], 3)
b2 <- round(coef(out1)[3], 3)
b3 <- round(coef(out1)[4], 3)

x1 <- testDat[1, "bp"]
x2 <- testDat[1, "glu"]
x3 <- testDat[1, "bmi"]

confInt <- round(
    predict(out1, newdat = testDat, interval = "confidence")[1, 2 : 3], 3
)
predInt <- round(
    predict(out1, newdat = testDat, interval = "prediction")[1, 2 : 3], 3
)
@ 

Training this model on the first $N = 400$ patients' data produces the following
fitted model:
\begin{align*}
  Y_{LDL} = \Sexpr{b0} + \Sexpr{b1} X_{BP} + \Sexpr{b2} X_{gluc} + 
  \Sexpr{b3} X_{BMI}
\end{align*}
\pause
Suppose a new patient presents with $BP = \Sexpr{x1}$, $gluc = \Sexpr{x2}$, and
$BMI = \Sexpr{x3}$. We can predict their $LDL$ score by:
\begin{align*}
  \hat{Y}_{LDL} &= \Sexpr{b0} + \Sexpr{b1} (\Sexpr{x1}) + \Sexpr{b2} 
  (\Sexpr{x2}) + \Sexpr{b3} (\Sexpr{x3})\\
  &= \Sexpr{round(predict(out1, testDat[1 : 2, ])[1], 3)}
\end{align*}

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{}
  
  \begin{center}
    \Huge{\textsc{Missing Data Imputation}}
  \end{center}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[shrink = 5]{Levels of Uncertainty Modeling}

  \citet{vanBuuren:2012} provides a very useful classification of different 
  imputation methods:
  \vb
  \begin{enumerate}
  \item Simple Prediction
    \begin{itemize}
    \item The missing data are naively filled with predicted values from some 
      regression equation.
    \item All uncertainty is ignored.
    \end{itemize}
    \vb
  \item Prediction + Noise
    \begin{itemize}
    \item A random residual error is added to each predicted value to create the 
      imputations.
    \item Only uncertainty in the predicted values is modeled.
    \item The imputation model itself is assumed to be correct and error-free.
    \end{itemize}
    \vb
  \item Prediction + Noise + Model Error
    \begin{itemize}
    \item Uncertainty in the imputation model itself is also modeled.
    \item Only way to get fully proper imputations in the sense of 
      \citet{rubin:1987}.
    \end{itemize}
  \end{enumerate}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[shrink = 5]{Do we really need to worry?}

  The arguments against single imputation can seem archaic and petty. Do we 
  really need to worry about this stuff?\\  
  \pause
  \vc
  \begin{itemize}
  \item YES!!! (At least if you care about inference)\\
  \end{itemize}
  \vb
  The following are results from a simple Monte Carlo simulation:
  
<<echo = FALSE, results = "asis">>=
simRes <- readRDS(paste0(figDir, "simResMat.rds"))

simResTab <- 
    xtable(simRes, 
           caption = "Mean Correlation Coefficients and Type I Error Rates",
           digits  = 3,
           align   = c("r", rep("c", 4))
           )

print(simResTab, scale = 0.8, booktabs = TRUE)
@ 

\pause
\vx{-12}
\begin{itemize}
\item Conditional mean substitution overestimates the correlation effect.
  \vc
\item Both single imputation methods inflate Type I error rates.
  \vc
\item MI provides unbiased point estimates and accurate Type I error rates.
\end{itemize}

\end{frame}

\watermarkoff %----------------------------------------------------------------%

\begin{frame}[fragile]{Simulate Some Toy Data}
  
<<size = "scriptsize">>=
nObs <- 1000 # Sample Size
pm   <- 0.3 # Proportion Missing

sigma <- matrix(c(1.0, 0.5, 0.0,
                  0.5, 1.0, 0.3,
                  0.0, 0.3, 1.0),
                ncol = 3)

simData <- as.data.frame(rmvnorm(nObs, c(0, 0, 0), sigma))
colnames(simData) <- c("y", "x", "z")

## Impose MAR Nonresponse:
misData <- simData
rVec    <- pnorm(misData$x,
                 mean = mean(misData$x),
                 sd   = sd(misData$x)) < pm
misData[rVec, "y"] <- NA

## Subset the data:
yMis <- misData[rVec, ]; yObs <- misData[!rVec, ]
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Look at the incomplete data.}

<<>>=
head(misData, n = 5)
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Expected Imputation Model Parameters}
    
<<>>=
## Get the imputation model moments:
lsFit <- lm(y ~ x + z, data = yObs)

beta  <- coef(lsFit)
sigma <- summary(lsFit)$sigma

beta
sigma
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Conditional Mean Substitution}

<<>>=
## Get deterministic imputations:
imp1 <- beta[1] + beta[2] * yMis[ , "x"] + 
    beta[3] * yMis[ , "z"]

## Fill missing cells in Y:
impData1            <- misData
impData1[rVec, "y"] <- imp1

head(impData1, n = 5)
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Stochastic Regression Imputation}
    
<<>>=
## Get stochastic imputations:
imp2 <- beta[1] + beta[2] * yMis[ , "x"] + 
    beta[3] * yMis[ , "z"] + rnorm(nrow(yMis), 0, sigma)

## Fill missing cells in Y:
impData2            <- misData
impData2[rVec, "y"] <- imp2

head(impData2, n = 5)
@ 

\end{frame}

\watermarkon %-----------------------------------------------------------------%

\begin{frame}[fragile]{Flavors of MI}
  
  MI simply repeats a single regression imputation $M$ times.
  \begin{itemize}
  \item The specifics of the underlying regression imputation are important.
  \end{itemize}
  \vb
  \pause
  Simply repeating the stochastic regression imputation procedure described 
  above won't suffice.
  \begin{itemize}
  \item Still produces too many Type I errors
  \end {itemize}
  
<<echo = FALSE, results = "asis">>=
simRes2 <- readRDS(paste0(figDir, "simResMat2.rds"))

simResTab2 <- 
    xtable(simRes2, 
           caption = "Mean Correlation Coefficients and Type I Error Rates",
           digits  = 3,
           align   = c("r", rep("c", 3))
           )

print(simResTab2, scale = 0.8, booktabs = TRUE) 
@

\vx{-16}
\begin{itemize}
\item Type I error rates for PN-Type MI are much better than they were for 
  single stochastic regression imputation, but they're still too high.
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Proper MI}
  
  The problems on the previous slide arise from using the same regression 
  coefficients to create each of the $M$ imputations.
  \begin{itemize}
  \item Implies that you're using the ``correct'' coefficients.
    \vb
  \item This assumption is plainly ridiculous.
    \begin{itemize}
    \item If we don't know some values of our outcome variable, how can we know 
      the ``correct'' coefficients to link the incomplete outcome to the 
      observed predictors?
    \end{itemize}
    \vb
    \pause
  \item Proper MI also models uncertainty in the regression coefficients used to 
    create the imputations.
    \begin{itemize}
    \item A different set of of coefficients is randomly sampled (using Bayesian 
      simulation) to create each of the $M$ imputations.
      \vc
    \item The tricky part about implemented MI is deriving the distributions 
      from which to sample these coefficients.
    \end{itemize}
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Setting Up Proper MI}
  
  Our imputation model is simply a linear regression model:
  \begin{align*}
    Y = \mathbf{X} \beta + \varepsilon
  \end{align*}
  To fully account for model uncertainty, we need to randomly sample both 
  $\beta$ and $\text{var}(\varepsilon) = \sigma^2$.
  \begin{itemize}
  \item \textsc{Question:} Why do we only sample $\sigma^2$ and not 
    $\varepsilon$?
  \end{itemize}
  \pause
  \va
  For a simple imputation model with a normally distributed outcome and 
  uninformative priors, we need to specify two distributions:
  \begin{enumerate}
    \item The marginal posterior distribution of $\sigma^2$
    \item The conditional posterior distribution of $\beta$ 
  \end{enumerate}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Marginal Distribution of $\sigma^2$}
 
  We first specify the marginal posterior distribution for the noise variance,
  $\sigma^2$.
  \vc
  \begin{itemize}
  \item This distribution does not depend on any other parameters.
  \end{itemize}
  \begin{align}
    \sigma^2 &\sim \text{Inv-}\chi^2 \left(N - P, MSE \right) \label{sigma2PosteriorEq}\\
    &\text{with } MSE = \frac{1}{N - P} \left( Y - \mathbf{X}\hat{\beta}_{ls} \right)^T \left( Y - \mathbf{X}\hat{\beta}_{ls} \right) \notag
  \end{align}
  \vx{-12}
  \begin{itemize}
  \item $\sigma^2$ follows a scaled inverse $\chi^2$ distribution.
  \end{itemize}

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Conditional Distribution of $\beta$}

  We then specify the conditional posterior distribution for $\beta$. 
  \vc
  \begin{itemize}
  \item This distribution is conditioned on a specific value of $\sigma^2$.
  \end{itemize}
  \begin{align}
    \beta \sim \text{MVN} \left( \hat{\beta}_{ls}, ~ \sigma^2 (\mathbf{X}^T \mathbf{X})^{-1} \right) \label{betaPosteriorEq}
  \end{align}
  \vx{-12}
  \begin{itemize}
  \item $\beta$ (conditionally) follows a multivariate normal distribution.
  \end{itemize}

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{PPD of the Missing Data}
  
  Once we've sampled our imputation model parameters, we can construct the 
  posterior predictive distribution of the missing data.
  \vc
  \begin{itemize}
  \item This is the distribution from which we sample our imputed values.
    \vc
  \item In practice, we directly compute the imputations based on the simulated 
    imputation model parameters.
  \end{itemize}
  \begin{align}
    Y_{imp} &= \mathbf{X}_{mis}\tilde{\beta} + \tilde{\varepsilon} \label{impPosteriorEq}\\
    &\text{with } \varepsilon \sim \text{N} \left( 0, \widetilde{\sigma^2} \right) \notag
  \end{align}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{General Steps for Basic MI}
  
  With all of the elements in place, we can execute a basic MI by following 
  these steps:
  \vb
  \begin{enumerate}
  \item Find the least squares estimates of $\beta$, $\hat{\beta}_{ls}$, by 
    regressing the observed portion of $Y$ onto the the analogous rows of 
    $\mathbf{X}$.
    \vb
  \item Use $\hat{\beta}_{ls}$ to parameterize the posterior distribution of 
    $\sigma^2$, given by Equation \ref{sigma2PosteriorEq}, and draw $M$ samples 
    of $\sigma^2$ from this distribution.
    \vb
  \item For each of the $\sigma^2_m$, sample a corresponding value of $\beta$ 
    from Equation \ref{betaPosteriorEq}.
    \vb
  \item Plug the $M$ samples of $\beta$ and $\sigma^2$ into Equation 
    \ref{impPosteriorEq} to create the $M$ imputations.
  \end{enumerate}
  
\end{frame}

\watermarkoff %----------------------------------------------------------------%

\begin{frame}[fragile]{Manual MI Example}
      
  First, we need to sample from the marginal posterior distribution of
  $\sigma^2$.
  
<<cache = TRUE>>=
## Define iteration numbers:
nImps <- 100
nSams <- 5000

## Get the expected betas:
fit0  <- lm(y ~ ., data = yObs)
beta0 <- coef(fit0)

## Sample sigma:
sigScale  <- (1 / fit0$df) * crossprod(resid(fit0))
sigmaSams <- 
    rinvchisq(nSams, df = fit0$df, scale = sigScale)
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Manual MI Example}
  
  Then we need to use those samples of $\sigma^2$ to parameterize the
  conditional posterior distribution of $\beta$ and sample from it.
  
<<cache = TRUE>>=
## Partition the predictor matrix:
misX <- as.matrix(cbind(1, yMis[ , c("x", "z")]))
obsX <- as.matrix(cbind(1, yObs[ , c("x", "z")]))

## Sample beta:
betaSams <- matrix(NA, nSams, ncol(obsX))
for(i in 1 : nSams) {
    betaVar       <- sigmaSams[i] * solve(crossprod(obsX))
    betaSams[i, ] <- 
        rmvnorm(1, mean = beta0, sigma = betaVar)
}
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Manual MI Example}
  
  Finally, we use the sampled imputation model moments to construct the missing 
  data's posterior predictive distribution:
  
<<cache = TRUE>>=
nMis   <- sum(rVec)
impMat <- matrix(NA, nMis, nSams)
for(i in 1 : nSams) {
    impMat[ , i] <- misX %*% matrix(betaSams[i, ]) +
        rnorm(nMis, 0, sqrt(sigmaSams[i]))
}

## Fill the missing cells with the M imputations:
impList <- list()
ind     <- sample(1 : nSams)
for(m in 1 : nImps) {
    impList[[m]]            <- misData
    impList[[m]][rVec, "y"] <- impMat[ , ind[m]]
}
@

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{What do we get?}
    
<<echo = FALSE, out.width = "65%">>=
par(mfrow = c(2, 3),
    cex = 0.5)

plot(density(betaSams[ , 1]),
     main = "Posterior Density of Intercept",
     xlab = "Intercept Value")

rect(par("usr")[1], 
     par("usr")[3], 
     par("usr")[2], 
     par("usr")[4], 
     col = "white")

lines(density(betaSams[ , 1]))

plot(density(betaSams[ , 2]),
     main = "Posterior Density of X Slope",
     xlab = "Slope Value")

rect(par("usr")[1], 
     par("usr")[3], 
     par("usr")[2], 
     par("usr")[4], 
     col = "white")

lines(density(betaSams[ , 2]))

plot(density(betaSams[ , 3]),
     main = "Posterior Density of Z Slope",
     xlab = "Slope Value")

rect(par("usr")[1], 
     par("usr")[3], 
     par("usr")[2], 
     par("usr")[4], 
     col = "white")

lines(density(betaSams[ , 3]))

for(i in 1 : 3) {
  obsNum <- c(1 : length(rVec))[rVec][i]
  plot(density(impMat[i, ]),
       main = paste0("Posterior Predictive Density of\nRow ",
         obsNum,
         "'s Missing Y Data"),
       xlab = "Y Value")

  rect(par("usr")[1], 
       par("usr")[3], 
       par("usr")[2], 
       par("usr")[4], 
       col = "white")
  
  lines(density(impMat[i, ]))
}
@

\end{frame}

\watermarkon %-----------------------------------------------------------------%

\begin{frame}{Doing MI-Based Analysis}
  
  An MI-based data analysis consists of three phases:
  \vb
  \begin{enumerate}
  \item The imputation phase \label{iStep}
    \begin{itemize}
    \item Replace missing values with $M$ plausible estimates.
    \item Produce $M$ completed datasets.
    \end{itemize}
    \vb
  \item The analysis phase \label{aStep}
    \begin{itemize}
    \item Estimate $M$ replicates of your analysis model.
    \item Fit the same model to each of the $M$ datasets from Step \ref{iStep}.
    \end{itemize}
    \vb
  \item The pooling phase
    \begin{itemize}
    \item Combine the $M$ sets of parameter estimates and standard errors from 
      Step \ref{aStep} into a single set of MI estimates.
    \item Use these pooled parameter estimates and standard errors for 
      inference.
    \end{itemize}
  \end{enumerate}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Pooling MI Estimates}
  
  \citet{rubin:1987} formulated a simple set of pooling rules for MI estimates.
  \vb
  \begin{itemize}
  \item The MI point estimate of some interesting quantity, $Q^*$, is simply 
    the mean of the $M$ estimates, $\{\hat{Q}_m\}$:
    \begin{align*}
      Q^* &= \frac{1}{M} \sum_{m = 1}^M \hat{Q}_m\\
    \end{align*}
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Pooling MI Estimates}
  
  The MI variability estimate, $T$, is a slightly more complex entity.
  \vb
  \begin{itemize}
  \item A weighted sum of the \emph{within-imputation} variance, $W$, and the 
    \emph{between-imputation} variance, $B$.
    \begin{align*}
      W &= \frac{1}{M} \sum_{m = 1}^M \widehat{SE}_{Q,m}^2\\
      B &= \frac{1}{M - 1} \sum_{m = 1}^M \left( \hat{Q}_m - Q^* \right)^2\\
      T &= W + \left( 1 + M^{-1} \right) B\\ 
      &= W + B + \frac{B}{M}
    \end{align*}
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Inference with MI Estimates}
  
  After computing $Q^*$ and $T$, we combine them in the usual way to get test 
  statistics and confidence intervals.
  \begin{align*}
    t &= \frac{Q^* - Q_0}{\sqrt{T}}\\
    CI &= Q^* \pm t_{crit} \sqrt{T}
  \end{align*}
  
  We must take care with our \emph{df}, though.
  \begin{align*}
    df = (M - 1) \left[1 + \frac{W}{\left(1 + M^{-1}\right)B}\right]^2
  \end{align*}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}{Fraction of Missing Information}
  
  In Lecture 4, we briefly discussed a very desirable measure of nonresponse: 
  \emph{fraction of missing information} (FMI).
  
  \begin{align*}
    FMI = \frac{r + \frac{2}{(df + 3)}}{r + 1} \approx \frac{(1 + M^{-1})B}{(1 + M^{-1})B + W} \rightarrow \frac{B}{B + W}
  \end{align*}
  where
  \begin{align*}
    r = \frac{(1 + M^{-1})B}{W}
  \end{align*}
  The FMI gives us a sense of how much the missing data (and their treatment) 
  have influence our parameter estimates.
  \vc
  \begin{itemize}
  \item We should report the FMI for an estimated parameter along with other 
    ancillary statistics (e.g., t-tests, p-values, effect sizes, etc.).
  \end{itemize}
  
\end{frame}

\watermarkoff %----------------------------------------------------------------%

\begin{frame}[fragile]{Example: Analysis \& Pooling}
  
  Analyze the multiply imputed datasets and pool results:
  
<<cache = TRUE>>=
## Use each dataset to estimate the analysis model:
fits1 <- lapply(impList, 
                function(dat) lm(z ~ x + y, data = dat)
                )

## Pool the results:
pool1 <- MIcombine(fits1)
summary(pool1, digits = 3)
@ 

\end{frame}

\watermarkon %-----------------------------------------------------------------%

\begin{frame}[allowframebreaks]{Model-Based vs. Donor-Based Methods}
  
  They types of MI we've discussed above are all \emph{model-based}.
  \vc
  \begin{itemize}
  \item The imputations are randomly sampled from an estimated distribution of 
    the missing values (i.e., a probability \emph{model} of the missing data).
  \end{itemize}
  \vb
  Model-based methods are theoretically ideal when the missing data truly follow 
  the chosen distribution.
  \vc
  \begin{itemize}
  \item If the missing data do not follow the model, performance suffers.
  \end{itemize}
  \vb
  Sometimes, the solution is to employ a different probability model.
  \vc
  \begin{itemize}
  \item We'll see this approach when we discuss MI for categorical variables.
  \end{itemize}
  
  \pagebreak
  
  If we're not able to choose a sensible distribution for the missing data, we 
  can use \emph{Donor-Based Methods}.
  \vc
  \begin{itemize}
  \item Imputations are sampled from a pool of matched observed cases.
    \vc
  \item The empirical distribution of the observed data is preserved.
  \end{itemize}
  \vb
  One particularly useful donor-based method is \emph{Predictive Mean Matching} 
  \citep{little:1988}.
  \begin{itemize}
  \item The cases that make up the donor pool are matched based on their 
    predicted outcome values.
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[allowframebreaks]{Predictive Mean Matching: Procedure}
  
  Suppose we want to generate $M$ imputations for an incomplete variable, $Y$, 
  using some set of predictors, $\mathbf{X}$.
  \vc
  \begin{enumerate}
  \item Regress $Y_{obs}$ onto $\mathbf{X}_{obs}$ and compute the conditional mean 
    of $Y_{obs}$: 
    \begin{itemize}
    \item $\hat{\mu} = \mathbf{X}_{obs} \hat{\beta}$
    \end{itemize}
    \vc
  \item Do a Bayesian linear regression of $Y_{obs}$ onto $\mathbf{X}_{obs}$ and 
    sample $M$ values of the posterior predicted mean of $Y_{mis}$: 
    \begin{itemize}
    \item $\tilde{\mu}_m = \mathbf{X}_{mis} \tilde{\beta}_m$.
    \end{itemize}
    \vc
  \item Compute $M$ sets of the matching distances: 
    \begin{itemize}
    \item $d(i, j)_m = (\tilde{\mu}_{mi} - \hat{\mu}_j)^2,~~i = 1, 2, \ldots N_{mis},~~j = 1, 2, \ldots, N_{obs}.$
    \end{itemize}
    
    \pagebreak
    
  \item Use each $d(i, j)_m$ to construct $N_{mis}$ donor pools. \label{findPools}
    \begin{itemize} 
    \item Find the $K$ (e.g., $K \in \{3, 5, 10\}$) cases with the smallest 
      values of $d(1, j)_m$, $d(2, j)_m$, $\ldots$, $d(N_{mis}, j)_m$. 
    \end{itemize}
    \vc
  \item For $m = 1, 2, \ldots, M$, select the final donor cases by randomly 
    sampling a single observation from each of the $N_{mis}$ donor pools defined 
    in Step \ref{findPools}. \label{findDonors}
    \vc
  \item For each of the $M$ imputations replace the missing values in $Y$ with 
    the donor data selected in Step \ref{findDonors}.
  \end{enumerate}
  
\end{frame}

\watermarkoff %----------------------------------------------------------------%

\begin{frame}[fragile]{Predictive Mean Matching: Example}

  Compute/sample the appropriate conditional means:
  
<<cache = TRUE>>=
## Define donor pool size:
K <- 5

## Conditional mean of Y_mis:
mu0 <- predict(fit0)

## Posterior predicted means of Y_mis:
mu1 <- as.data.frame(
    misX %*% t(betaSams[sample(1 : nSams, nImps), ])
)
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Predictive Mean Matching: Example}

  Define a function to find donor cases:
  
<<>>=
getDonors <- function(x, y, K) {
    ## Compute distances:
    d <- (x - y)^2
    
    ## Indices of the K smallest distances:
    ind <- which(order(d) %in% 1 : K)
    
    ## Return a randomly sampled index:
    sample(ind, 1)
}
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Predictive Mean Matching: Example}

  Implement the imputation:
  
<<cache = TRUE>>=
impList2 <- list()
for(m in 1 : nImps) {
    ## Find donor cases:
    d0 <- sapply(mu1[ , m], getDonors, y = mu0, K = K)
    
    ## Impute the missing values:
    impData            <- misData
    impData[rVec, "y"] <- yObs$y[d0]
    
    ## Save the imputed dataset:
    impList2[[m]] <- impData
}
@ 

\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[fragile]{Predictive Mean Matching: Example}
<<>>=
## Use each dataset to estimate the analysis model:
fits2 <- lapply(impList2, 
                function(dat) lm(z ~ x + y, data = dat)
                )

## Pool the results:
pool2 <- MIcombine(fits2)
summary(pool2, digits = 3)
@

\end{frame}

\watermarkon %-----------------------------------------------------------------%

\begin{frame}{Pros and Cons of Predictive Mean Matching}
  
  PMM tends to work well with continuous, non-normal variables.
  \begin{itemize}
  \item Relatively robust to misspecification of the imputation model
  \item Imputed values are always valid
  \end{itemize}
  \vb
  PMM does have some important limitations.
  \begin{itemize}
  \item In small samples, the same donor cases can be re-used many times.
  \item PMM cannot extrapolate beyond the observed range of the data.
  \item PMM cannot be used with some variable types.
    \begin{itemize}
    \item Nominal variables
    \end{itemize}
  \item PMM may perform poorly when the number of predictor variables is small.
  \end{itemize}
  
\end{frame}

%------------------------------------------------------------------------------%

\begin{frame}[allowframebreaks]{References}
  
  \bibliographystyle{apacite}
  \bibliography{../../../literature/bibtexFiles/statMethRefs.bib,../../../literature/bibtexFiles/dissRefsList.bib}
  
\end{frame}

%------------------------------------------------------------------------------%

\end{document}

